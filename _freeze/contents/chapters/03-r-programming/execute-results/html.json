{
  "hash": "db6518b8cfa9960ec0b577c5507704b4",
  "result": {
    "engine": "knitr",
    "markdown": "# R Programming Essentials\n\nIn this chapter, you'll learn the core building blocks of R programming --- variables, data types, vectors, flow control, and functions. These are the tools you'll use throughout the rest of this book.\n\nTo make these concepts concrete, we'll use a **running clinical example** that builds from section to section.\n\n::: {.callout-note}\n## Our running example: Estimating kidney function\n\nThroughout this chapter, we'll progressively build up a calculation using the **Cockcroft-Gault equation** --- a widely used formula for estimating creatinine clearance (a measure of kidney function):\n\n$$\neCrCl = \\frac{(140 - age) \\times weight_{kg}}{72 \\times Cr_{mg/dL}} \\times (0.85 \\text{ if female})\n$$\n\nStarting from simple arithmetic, we'll add variables, handle multiple patients, classify results into CKD stages, and finally wrap everything into a reusable function. Each section introduces a new R concept and applies it to this scenario.\n:::\n\n\n## R as a Calculator\n\nAt its core, R is a powerful calculator. Type a mathematical expression, and R gives you the answer:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2 + 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n100 / 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 33.33333\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2^10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1024\n```\n\n\n:::\n:::\n\n\nHere are R's arithmetic operators:\n\n| Operator | Meaning          | Example   |\n|----------|------------------|-----------|\n| `+`      | Addition         | `5 + 3`   |\n| `-`      | Subtraction      | `10 - 4`  |\n| `*`      | Multiplication   | `6 * 7`   |\n| `/`      | Division         | `100 / 3` |\n| `^`      | Exponent (power) | `2 ^ 3`   |\n\nLike in mathematics, **parentheses** control the order of operations:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(2 + 3) * 4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2 + 3 * 4      # without parentheses: multiplication first\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 14\n```\n\n\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n## A note about `print()`\nUnlike other programming language, In R, when you type an expression in the **Console**, an **R Script** (run line-by-line), or a **Quarto code chunk**, R automatically prints the result. You don't need to wrap it in `print()` --- just write the expression and R will display the output. This is called **auto-printing**, and it's why `2 + 3` shows `5` without us writing `print(2 + 3)`.\n:::\n\n### Your first clinical calculation\n\nLet's try something more relevant. The Cockcroft-Gault equation for a 55-year-old male patient weighing 70 kg with a serum creatinine of 1.2 mg/dL:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(140 - 55) * 70 / (72 * 1.2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 68.86574\n```\n\n\n:::\n:::\n\n\nAn estimated creatinine clearance of about 69 mL/min. But typing raw numbers like this is hard to read and easy to get wrong. Let's fix that with **variables**.\n\n\n## Variables and Assignment\n\nA **variable** stores a value so you can use it later by name. In R, you create variables with the **assignment operator** `<-`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage <- 55\n```\n:::\n\n\nThis stores the number `55` in a variable called `age`. You can now use `age` anywhere in place of `55`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 55\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n140 - age\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 85\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip}\n## The `<-` shortcut\nIn RStudio, press **Alt + -** (Windows/Linux) or **Option + -** (macOS) to type `<-`. You'll use this thousands of times --- it's worth memorizing.\n:::\n\n::: {.callout-note}\n## What about `=`?\nYou may see `=` used for assignment in some R code (e.g., `age = 55`). It works in most situations, but `<-` is the **standard convention** in the R community and is what you'll see in virtually all R books, packages, and style guides. We'll use `<-` throughout this book.\n:::\n\n### Naming conventions\n\nVariable names should be descriptive. R convention is **snake_case** --- lowercase words separated by underscores:\n\n| Good names         | Bad names    | Why bad?                     |\n|--------------------|--------------|------------------------------|\n| `age`              | `a`          | Not descriptive              |\n| `weight_kg`        | `Weight.KG`  | Inconsistent casing          |\n| `serum_creatinine` | `x1`         | Meaningless name             |\n| `patient_count`    | `myVar`      | Vague, camelCase not standard |\n\n::: {.callout-warning}\n## Naming rules\nVariable names must start with a letter and can contain letters, numbers, underscores (`_`), and dots (`.`). They are **case-sensitive** --- `Age` and `age` are different variables. Avoid spaces and special characters.\n:::\n\n### Building the eGFR calculation with variables\n\nLet's store our patient's data in properly named variables:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage        <- 55\nweight_kg  <- 70\ncreatinine <- 1.2    # serum creatinine in mg/dL\nsex        <- \"Male\"\n```\n:::\n\n\nNow the Cockcroft-Gault calculation becomes readable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\negfr <- (140 - age) * weight_kg / (72 * creatinine)\negfr\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 68.86574\n```\n\n\n:::\n:::\n\n\nMuch better. Each number has a name, and if you need to change a value (say, a different patient's age), you only change it in one place.\n\n::: {.callout-caution collapse=\"true\" title=\"Python Comparison\"}\nIn Python, `=` is the only assignment operator:\n\n```python\nage = 55\nweight_kg = 70\ncreatinine = 1.2\nsex = \"Male\"\n```\n\nBoth R and Python use `snake_case` as the preferred naming convention.\n:::\n\n\n## Data Types\n\nEvery value in R has a **type**. Understanding types helps you avoid errors and work with data correctly.\n\nR has four basic types you'll encounter regularly:\n\n| Type        | Stores           | Examples                 |\n|-------------|------------------|--------------------------|\n| `numeric`   | Numbers          | `3.14`, `42`, `-7.5`    |\n| `character` | Text (strings)   | `\"hello\"`, `\"Male\"`     |\n| `logical`   | True / False     | `TRUE`, `FALSE`          |\n| `factor`    | Categories       | *(covered in next chapter)* |\n\n### Numeric\n\nNumbers are the most common type. R stores most numbers as **doubles** (decimal numbers):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(creatinine)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n:::\n\n\nEven `55` (a whole number) is stored as a double internally.\n\n### Character\n\nText values are called **character** strings. They must be wrapped in quotes (`\"` or `'`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsex <- \"Male\"\ndiagnosis <- \"Chronic Kidney Disease\"\ntypeof(sex)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n### Logical\n\nLogical values are either `TRUE` or `FALSE`. They often come from comparisons:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_impaired <- egfr < 60\nis_impaired\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(is_impaired)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n:::\n\n\nOur patient's eGFR of ~69 is not below 60, so `is_impaired` is `FALSE`.\n\n### Checking types\n\nUse `class()` for a quick type check:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(sex)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(is_impaired)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n:::\n\n\n::: {.callout-note}\n## What about factors?\nA **factor** is a special type for categorical data (like blood group: A, B, AB, O). We'll explore factors in the next chapter when we work with data frames. For now, just know they exist.\n:::\n\n::: {.callout-caution collapse=\"true\" title=\"Python Comparison\"}\nPython's type names differ slightly:\n\n| R           | Python        | Example          |\n|-------------|---------------|------------------|\n| `numeric`   | `int`/`float` | `42`, `3.14`     |\n| `character` | `str`         | `\"hello\"`        |\n| `logical`   | `bool`        | `True`, `False`  |\n\nNote: Python booleans are capitalized (`True`/`False`) but not all-caps like R's `TRUE`/`FALSE`.\n\n```python\ntype(42)       # <class 'int'>\ntype(\"Male\")   # <class 'str'>\ntype(True)     # <class 'bool'>\n```\n:::\n\n\n## Vectors\n\nA **vector** is R's fundamental data structure --- an ordered collection of values of the same type. Almost everything in R is a vector; even a single number like `42` is a vector of length 1.\n\n### Creating vectors\n\nUse `c()` (short for **c**ombine) to create a vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nages <- c(55, 70, 45, 62, 38)\nages\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 55 70 45 62 38\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsexes <- c(\"Male\", \"Female\", \"Male\", \"Female\", \"Male\")\nsexes\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Male\"   \"Female\" \"Male\"   \"Female\" \"Male\"  \n```\n\n\n:::\n:::\n\n\nThe **`:`** operator creates a sequence of integers --- useful for generating regular number sequences without typing each one:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n10:15\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10 11 12 13 14 15\n```\n\n\n:::\n:::\n\n\n### Indexing or Subsetting\n\nAccess elements by position using square brackets `[]`. **R uses 1-based indexing** --- the first element is `[1]`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nages[1]      # first patient\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 55\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nages[2:4]    # patients 2 through 4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 70 45 62\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nages[-1]     # all EXCEPT the first\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 70 45 62 38\n```\n\n\n:::\n:::\n\n\n### Vectorized operations --- R's superpower\n\nThis is one of R's most powerful features: operations apply to **every element at once**, without needing a loop.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nages + 10    # add 10 to every age\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 65 80 55 72 48\n```\n\n\n:::\n:::\n\n\nLet's use this to compute eGFR for five patients simultaneously:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Five clinic patients\nages         <- c(55, 70, 45, 62, 38)\nweights      <- c(70, 58, 82, 65, 90)\ncreatinines  <- c(1.2, 1.8, 0.9, 2.1, 1.0)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate eGFR for ALL patients at once (without sex adjustment for now)\negfrs <- (140 - ages) * weights / (72 * creatinines)\negfrs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  68.86574  31.32716 120.21605  33.53175 127.50000\n```\n\n\n:::\n:::\n\n\nOne line of code --- five eGFR results. No loops needed. We'll add the sex adjustment factor later when we learn about functions.\n\n::: {.callout-tip}\n## Why vectorization matters\nIn many languages, you'd write a `for` loop to process each patient one at a time. R's vectorized operations are not only more concise --- they're also **faster**, because R optimizes the computation internally.\n:::\n\n### Summary functions\n\nR provides built-in functions to summarize vectors:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(egfrs)      # average eGFR\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 76.28814\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmedian(egfrs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 68.86574\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmin(egfrs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 31.32716\n```\n\n\n:::\n\n```{.r .cell-code}\nmax(egfrs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 127.5\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(egfrs)    # how many patients\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(egfrs, 1)  # round to 1 decimal place\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  68.9  31.3 120.2  33.5 127.5\n```\n\n\n:::\n:::\n\n\n::: {.callout-caution collapse=\"true\" title=\"Python Comparison\"}\nR vectors and Python lists look similar but behave differently:\n\n```python\n# Python list — NOT vectorized by default\nages = [55, 70, 45, 62, 38]\nages + 10        # TypeError!\nages[0]          # 55 — 0-based indexing!\n\n# For vectorized operations, use NumPy\nimport numpy as np\nages = np.array([55, 70, 45, 62, 38])\nages + 10        # array([65, 80, 55, 72, 48])\n```\n\nKey difference: **R is 1-based** (`ages[1]` is the first), **Python is 0-based** (`ages[0]` is the first).\n:::\n\n\n## Logical Operations and Comparisons\n\nComparisons produce logical values (`TRUE` / `FALSE`). These are essential for filtering and classifying data.\n\n### Comparison operators\n\n| Operator | Meaning            | Example   |\n|----------|--------------------|-----------|\n| `==`     | Equal to           | `x == 5`  |\n| `!=`     | Not equal to       | `x != 5`  |\n| `>`      | Greater than       | `x > 5`   |\n| `<`      | Less than          | `x < 5`   |\n| `>=`     | Greater or equal   | `x >= 5`  |\n| `<=`     | Less than or equal | `x <= 5`  |\n\n::: {.callout-warning}\n## `==` for comparison, `<-` for assignment\nUse `==` to **test** equality (\"is this equal to?\") and `<-` to **assign** a value (\"store this\"). Mixing them up is a common source of bugs.\n:::\n\nWhen applied to vectors, comparisons are **vectorized**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\negfrs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  68.86574  31.32716 120.21605  33.53175 127.50000\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Which patients have impaired kidney function (eGFR < 60)?\negfrs < 60\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\nTwo of our five patients have eGFR below 60.\n\n### Filtering with logical vectors\n\nYou can use a logical vector to **subset** another vector --- extracting only the elements where the condition is `TRUE`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract only the impaired eGFR values\negfrs[egfrs < 60]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 31.32716 33.53175\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# What ages correspond to impaired kidneys?\nages[egfrs < 60]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 70 62\n```\n\n\n:::\n:::\n\n\n### Combining conditions\n\nUse `&` (AND), `|` (OR), and `!` (NOT) to combine conditions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Patients older than 50 with eGFR < 60\negfrs < 60 & ages > 50\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n### The `%in%` operator\n\n`%in%` checks whether values exist in a given set:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nblood_types <- c(\"A\", \"B\", \"O\", \"AB\", \"A\")\nblood_types %in% c(\"A\", \"O\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE  TRUE FALSE  TRUE\n```\n\n\n:::\n:::\n\n\n### Counting with logical vectors\n\nA useful trick: `TRUE` counts as `1` and `FALSE` as `0`. This means `sum()` counts the `TRUE`s, and `mean()` gives the proportion:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(egfrs < 60)     # how many patients have eGFR < 60?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(egfrs < 60)    # what proportion?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.4\n```\n\n\n:::\n:::\n\n\n40% of our patients (2 out of 5) have eGFR below 60.\n\n\n## Missing Values (`NA`) {#sec-na}\n\nReal medical data is rarely complete. Lab results may be pending, forms may have blank fields, or data entry may have been skipped. R represents missing values as **`NA`** (Not Available).\n\n### `NA` is contagious\n\nAny calculation involving `NA` returns `NA` --- because if you don't know a value, you can't know the result:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNA + 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNA > 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNA == NA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\nThat last one may surprises you. `NA == NA` returns `NA` because: if you don't know what either value is, you can't tell whether they're equal.\n\n### Detecting missing values\n\nUse `is.na()` to test for `NA`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(10, NA, 30, NA, 50)\nis.na(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n!is.na(x)    # the opposite: which are NOT missing?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE  TRUE FALSE  TRUE\n```\n\n\n:::\n:::\n\n\n### The `na.rm` argument\n\nMany summary functions return `NA` when the input contains missing values:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# What if patient 3's creatinine result is pending?\ncreatinines_with_na <- c(1.2, 1.8, NA, 2.1, 1.0)\nmean(creatinines_with_na)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\nThe mean of \"something unknown\" is unknown. To skip the missing value, use `na.rm = TRUE` (**r**e**m**ove NAs):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(creatinines_with_na, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.525\n```\n\n\n:::\n:::\n\n\nNow R computes the mean of the four known values, ignoring the missing one.\n\n::: {.callout-tip}\n## `na.rm` is everywhere\nMost summary functions in R --- `mean()`, `sum()`, `median()`, `sd()`, `min()`, `max()` --- accept `na.rm = TRUE`. You'll use it frequently with real-world datasets.\n:::\n\n::: {.callout-caution collapse=\"true\" title=\"Python Comparison\"}\nPython uses `None` and `NaN` (Not a Number) for missing values:\n\n```python\nimport numpy as np\nimport pandas as pd\n\nx = [1, 2, None, 4]\npd.isna(x)                     # like is.na()\nnp.nanmean([1, 2, np.nan, 4])  # like mean(..., na.rm = TRUE)\n```\n\nPandas DataFrames also provide `.dropna()` and `.fillna()` for handling missing data.\n:::\n\n\n## Flow Control {#sec-flow-control}\n\nSometimes you need R to make decisions: \"if the eGFR is above 90, classify as normal; otherwise, check the next threshold.\" This is **flow control**.\n\n### `if` / `else`\n\nThe simplest form makes a **two-way decision**: do one thing if a condition is true, something else if it's false.\n\n```r\nif (condition) {\n  # do this when TRUE\n} else {\n  # do this when FALSE\n}\n```\n\nLet's check whether a patient's kidney function is impaired:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npatient_egfr <- 68.9\n\nif (patient_egfr < 60) {\n  status <- \"Impaired\"\n} else {\n  status <- \"Normal\"\n}\n\nstatus\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Normal\"\n```\n\n\n:::\n:::\n\n\nOur patient's eGFR of 68.9 is not below 60, so the result is `\"Normal\"`.\n\n### `if` / `else if` / `else`\n\nWhen you have **more than two categories**, add `else if` branches. Each condition is checked in order --- R takes the **first** one that is `TRUE` and skips the rest.\n\nLet's classify kidney function into simplified CKD stages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npatient_egfr <- 68.9\n\nif (patient_egfr >= 90) {\n  stage <- \"G1 (Normal)\"\n} else if (patient_egfr >= 60) {\n  stage <- \"G2 (Mild decrease)\"\n} else if (patient_egfr >= 30) {\n  stage <- \"G3 (Moderate decrease)\"\n} else {\n  stage <- \"G4-G5 (Severe decrease)\"\n}\n\nstage\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"G2 (Mild decrease)\"\n```\n\n\n:::\n:::\n\n\nThe eGFR of 68.9 didn't satisfy `>= 90` (first branch), but it did satisfy `>= 60` (second branch), so R assigned `\"G2 (Mild decrease)\"` and stopped checking.\n\n::: {.callout-note}\n## Simplified CKD staging\nWe're using a simplified 4-level classification for teaching purposes. The full [KDIGO staging system](https://kdigo.org/guidelines/ckd-evaluation-and-management/) divides kidney function into 6 stages (G1, G2, G3a, G3b, G4, G5).\n:::\n\n### Vectorized `ifelse()`\n\nThe `if` / `else` statement works on a **single value**. For vectors, use `ifelse()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Classify all patients as \"Impaired\" or \"Normal\" at once\nifelse(egfrs < 60, \"Impaired\", \"Normal\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Normal\"   \"Impaired\" \"Normal\"   \"Impaired\" \"Normal\"  \n```\n\n\n:::\n:::\n\n\n::: {.callout-tip}\n## When to use which?\n- **`if` / `else`** → for a **single** condition (one patient)\n- **`ifelse()`** → for a **vector** of values (multiple patients at once)\n\nIn later chapters, we'll learn an even more powerful tool for multi-level classification: `dplyr::case_when()`.\n:::\n\n### `for` loops (brief)\n\nA `for` loop repeats an action for each element in a sequence:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:3) {\n  cat(\"Patient\", i, \": eGFR =\", round(egfrs[i], 1), \"\\n\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nPatient 1 : eGFR = 68.9 \nPatient 2 : eGFR = 31.3 \nPatient 3 : eGFR = 120.2 \n```\n\n\n:::\n:::\n\n\n::: {.callout-note}\n## Loops are uncommon in idiomatic R\nYou'll rarely write `for` loops in day-to-day R code. R's vectorized operations and the tidyverse functions we'll learn in later chapters handle most iteration more elegantly. We mention loops here so you recognize them, but don't worry if they feel unfamiliar.\n:::\n\n::: {.callout-caution collapse=\"true\" title=\"Python Comparison\"}\nPython uses indentation instead of braces for code blocks:\n\n```python\n# Python\nif egfr >= 90:\n    stage = \"G1 (Normal)\"\nelif egfr >= 60:\n    stage = \"G2 (Mild decrease)\"\nelif egfr >= 30:\n    stage = \"G3 (Moderate decrease)\"\nelse:\n    stage = \"G4-G5 (Severe decrease)\"\n```\n\nKey differences: `elif` (not `else if`), colon `:` after each condition, and **indentation** defines the blocks (no `{}`).\n:::\n\n\n## Functions {#sec-functions}\n\nYou've already been using functions throughout this chapter --- `mean()`, `round()`, `c()`, `is.na()`. A **function** takes inputs (called **arguments**), does something with them, and returns a result.\n\n```{mermaid}\n%%| label: fig-function-diagram\n%%| fig-cap: \"How a function works: inputs go in, output comes out.\"\nflowchart LR\n  A[\"1.2, 1.8\"] -->|input| B[\"mean()\"]\n  B -->|output| C[\"1.5\"]\n\n  D[\"68.865\"] -->|input| E[\"round(, 1)\"]\n  E -->|output| F[\"68.9\"]\n```\n\n### Where do functions come from?\n\nFunctions in R generally come from three sources:\n\n| Source | Examples | Documentation |\n|---|---|---|\n| **Base R** --- built into R itself | `mean()`, `round()`, `sum()`, `paste()` | Always available, no `library()` needed |\n| **R packages** --- installed add-ons (see more @sec-r-pkg) | `readr::read_csv()`, `dplyr::filter()` | Available after `library()` or via `::` |\n| **User-defined** --- written by you | `classify_ckd()`, `estimate_egfr()` | No built-in docs (unless you build a package) |\n\nEverything you've used so far --- `mean()`, `c()`, `is.na()`, `round()` --- comes from **base R**. In later chapters, we'll rely heavily on functions from **R packages** (especially the tidyverse). In this section, you'll learn to write your own **user-defined** functions.\n\n### Getting help\n\nFor base R and package functions, type `?` followed by the function name in the console to view its documentation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?mean\n?round\n```\n:::\n\n\nThe help page appears in RStudio's Help pane, showing the function's description, arguments, and examples.\n\n::: {.callout-tip}\n## Can't remember the exact name?\nUse `??` (double question mark) to **search** across all documentation. For example, `??correlation` will find functions related to correlation, even if you don't know the exact function name.\n:::\n\n::: {.callout-note}\n## `?` doesn't work for user-defined functions\nThe `?` help system only works for functions that come with documentation --- i.e., base R and installed packages. Functions you write yourself (like the ones we'll create below) won't have help pages unless you package them into an R package with documentation.\n:::\n\n### Writing your own functions\n\nNow let's learn to create **user-defined** functions. The syntax is:\n\n```r\nfunction_name <- function(arg1, arg2, arg3) {\n  # body: do something with the arguments\n  result    # the last expression is automatically returned\n}\n```\n\nLet's break this down piece by piece:\n\n- **`function_name`** --- the name you give your function. Follow the same `snake_case` naming rules as variables. Pick a name that describes what the function *does* (e.g., `classify_ckd`, `estimate_egfr`).\n- **`function(...)`** --- the `function` keyword tells R you're creating a function. This is followed by parentheses containing the arguments.\n- **`arg1, arg2, arg3`** --- the **arguments** (inputs). These are placeholder names for the values the caller will provide. You can have zero, one, or many arguments.\n- **`{ ... }`** --- the **body**, wrapped in curly braces. This is the code that runs when the function is called. It can be one line or many lines.\n- **Return value** --- R automatically returns the **last expression** evaluated in the body. You don't need an explicit `return()` statement (though you can use one if you prefer).\n\nLet's start by turning our CKD staging code into a reusable function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclassify_ckd <- function(egfr) {\n  if (egfr >= 90) {\n    \"G1 (Normal)\"\n  } else if (egfr >= 60) {\n    \"G2 (Mild decrease)\"\n  } else if (egfr >= 30) {\n    \"G3 (Moderate decrease)\"\n  } else {\n    \"G4-G5 (Severe decrease)\"\n  }\n}\n```\n:::\n\n\nNow we can classify any eGFR value with a single call:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclassify_ckd(68.9)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"G2 (Mild decrease)\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclassify_ckd(25.3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"G4-G5 (Severe decrease)\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclassify_ckd(95.0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"G1 (Normal)\"\n```\n\n\n:::\n:::\n\n\n### Positional vs named arguments\n\nWhen calling a function, you can pass arguments in two ways:\n\n- **By position** --- R matches arguments left to right, based on the order defined in the function.\n- **By name** --- you explicitly say which argument gets which value using `=`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(68.865, 1)             # by position: x = 68.865, digits = 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 68.9\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(x = 68.865, digits = 1) # by name: same result, more explicit\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 68.9\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(digits = 1, x = 68.865) # named args can be in any order\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 68.9\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip}\n## When to use named arguments\nFor functions with one or two arguments, positional is fine --- `round(68.865, 1)` is clear enough. But when a function has many arguments, **naming** them makes your code much easier to read. Compare:\n\n- `estimate_egfr(55, 70, 1.2, \"Female\")` --- what is `70`? What is `1.2`?\n- `estimate_egfr(age = 55, weight_kg = 70, creatinine = 1.2, sex = \"Female\")` --- self-documenting\n:::\n\n### Default arguments\n\nSometimes a function argument has a sensible \"usual\" value. You can specify a **default** by using `=` in the function definition:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngreet <- function(name, greeting = \"Hello\") {\n  paste(greeting, name)\n}\n```\n:::\n\n\nIf the caller doesn't provide `greeting`, R uses the default:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngreet(\"Dr. Smith\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hello Dr. Smith\"\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngreet(\"Dr. Smith\", greeting = \"Good morning\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Good morning Dr. Smith\"\n```\n\n\n:::\n:::\n\n\nThis is useful when most calls use the same value, but you still want the flexibility to override it.\n\n### The complete eGFR function\n\nNow let's build the full Cockcroft-Gault calculation, combining everything we've learned --- arithmetic, variables, if-else, default arguments, and function definition:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nestimate_egfr <- function(age, weight_kg, creatinine, sex = \"Male\") {\n  egfr <- (140 - age) * weight_kg / (72 * creatinine)\n\n  # Apply sex correction factor\n  if (sex == \"Female\") {\n    egfr <- egfr * 0.85\n  }\n\n  round(egfr, 1)\n}\n```\n:::\n\n\nHere, `sex = \"Male\"` is a default argument --- if the caller doesn't specify sex, it assumes male (no correction applied).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Male patient (default sex)\nestimate_egfr(age = 55, weight_kg = 70, creatinine = 1.2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 68.9\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Female patient (with 0.85 correction)\nestimate_egfr(age = 70, weight_kg = 58, creatinine = 1.8, sex = \"Female\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 26.6\n```\n\n\n:::\n:::\n\n\nThe female correction factor (× 0.85) lowered the estimate from 31.3 to 26.6 --- a clinically meaningful difference that shifts the CKD stage from G3 to G4--G5.\n\n### Applying functions to vectors\n\nUse `sapply()` to apply a function to each element of a vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Classify each patient's CKD stage\nsapply(round(egfrs, 1), classify_ckd)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"G2 (Mild decrease)\"     \"G3 (Moderate decrease)\" \"G1 (Normal)\"           \n[4] \"G3 (Moderate decrease)\" \"G1 (Normal)\"           \n```\n\n\n:::\n:::\n\n\n::: {.callout-note}\n## Better tools are coming\n`sapply()` works for simple cases, but in later chapters you'll learn `dplyr::mutate()` with `case_when()` --- a much more elegant way to classify and transform columns in a data frame.\n:::\n\n::: {.callout-caution collapse=\"true\" title=\"Python Comparison\"}\nPython defines functions with `def`:\n\n```python\ndef estimate_egfr(age, weight_kg, creatinine, sex=\"Male\"):\n    egfr = (140 - age) * weight_kg / (72 * creatinine)\n    if sex == \"Female\":\n        egfr *= 0.85\n    return round(egfr, 1)\n```\n\nKey differences: `def` keyword (not `function()`), colon after declaration, explicit `return` statement, and indentation-based blocks.\n:::\n\n\n## Packages {#sec-r-pkg}\n\nR comes with useful built-in functions, but its real strength lies in **packages** --- add-ons created by the R community. Think of them as **apps for your phone**: R is the operating system, and packages are the apps that add new capabilities.\n\n### Installing vs loading\n\nThere's an important distinction:\n\n| Action | Command | Frequency |\n|---|---|---|\n| **Install** a package | `install.packages(\"name\")` | Once |\n| **Load** a package | `library(name)` | Every R session |\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Install (one time — downloads the package)\ninstall.packages(\"tidyverse\")\n\n# Load (every session — makes functions available)\nlibrary(tidyverse)\n```\n:::\n\n\n::: {.callout-warning}\n## Install once, load every time\nThink of it like apps: you **install** an app once from the store, but you **open** it each time you want to use it. Same with R packages.\n:::\n\n### The `::` notation\n\nYou can use a single function from a package without loading the entire package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreadr::read_csv(\"data/diabetes.csv\")\n```\n:::\n\n\nThe `package::function()` syntax is useful when you only need one function, or when two packages have functions with the same name.\n\n### The tidyverse\n\nThe **tidyverse** is a collection of R packages designed for data science. It's the core toolkit we'll use for the rest of this book:\n\n| Package   | Purpose                        |\n|-----------|--------------------------------|\n| `readr`   | Reading data files (CSV, etc.) |\n| `dplyr`   | Data manipulation              |\n| `tidyr`   | Reshaping data                 |\n| `ggplot2` | Data visualization             |\n| `stringr` | Working with text              |\n| `purrr`   | Functional programming         |\n| `tibble`  | Modern data frames             |\n\n: Core tidyverse packages --- load all at once with `library(tidyverse)` {.striped}\n\nWe'll explore these packages in depth starting from the next chapter.\n\n::: {.callout-caution collapse=\"true\" title=\"Python Comparison\"}\nPython uses `pip` for installation and `import` for loading:\n\n```python\n# Install (in terminal)\npip install pandas\n\n# Load (in script)\nimport pandas as pd\n\n# Use\npd.read_csv(\"data/diabetes.csv\")\n```\n\nR's `library(dplyr)` is analogous to Python's `import pandas as pd`.\n:::\n\n\n## The Pipe Operator {#sec-pipe}\n\nAs your code becomes more complex, you'll often chain multiple operations together. Without a pipe, this means **nesting** function calls:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Nested: read from inside out\nsort(round(egfrs, 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  31.3  33.5  68.9 120.2 127.5\n```\n\n\n:::\n:::\n\n\nTo read this, you start from the innermost function (`round`) and work outward (`sort`). With two functions it's manageable, but add a few more and it quickly becomes unreadable.\n\n### The `|>` pipe\n\nR's pipe operator `|>` lets you write operations **left to right**, like reading a sentence:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Piped: read left to right\negfrs |> round(1) |> sort()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  31.3  33.5  68.9 120.2 127.5\n```\n\n\n:::\n:::\n\n\nRead this as: *\"Take `egfrs`, **then** round to 1 decimal, **then** sort.\"*\n\nThe pipe takes the result from the left side and passes it as the **first argument** to the function on the right.\n\n| Step | Expression         | Passes result to |\n|------|--------------------|------------------|\n| 1    | `egfrs`            | `round()`        |\n| 2    | `round(egfrs, 1)`  | `sort()`         |\n| 3    | `sort(...)`        | final result     |\n\nHere's a more practical example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Without pipe\nround(mean(c(1, 2, NA, 4), na.rm = TRUE), 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.33\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# With pipe — reads naturally\nc(1, 2, NA, 4) |> mean(na.rm = TRUE) |> round(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.33\n```\n\n\n:::\n:::\n\n\n*\"Take these numbers, then compute the mean (removing NAs), then round to 2 decimal places.\"*\n\n### `|>` vs `%>%`\n\nYou may encounter `%>%` in older R code or online tutorials. This is the **magrittr** pipe, which was R's original pipe before version 4.1 (2021) added `|>` as a built-in feature.\n\nBoth work similarly for most use cases. We'll use **`|>`** throughout this book since it requires no extra packages and is the modern standard.\n\n::: {.callout-caution collapse=\"true\" title=\"Python Comparison\"}\nPython doesn't have a pipe operator. Instead, it uses **method chaining** with the dot `.`:\n\n```python\n(df\n  .query(\"age > 50\")\n  .sort_values(\"glucose\")\n  .head(10)\n)\n```\n\nConceptually similar to R's pipe --- both enable left-to-right reading of sequential data transformations.\n:::\n\n\n## How to Read Error Messages {#sec-errors}\n\nError messages are R's way of telling you something went wrong. They can feel cryptic at first, but they follow patterns. Learning to read them is the **#1 beginner survival skill**.\n\n### Errors vs warnings vs messages\n\n- **Error** → code **stopped**. Something is broken and needs fixing.\n- **Warning** → code **ran**, but R thinks something might be off.\n- **Message** → purely informational (e.g., which packages were loaded).\n\n### Common errors and what they mean\n\n| Error Message                   | What It Means                                          |\n|---------------------------------|--------------------------------------------------------|\n| `object 'x' not found`         | Typo in variable name, or forgot to run the line that creates it |\n| `could not find function`       | Package not loaded --- did you forget `library()`?     |\n| `unexpected ')' in ...`         | Mismatched parentheses --- count your opening and closing parens |\n| `non-numeric argument`          | Used text where a number was expected                  |\n| `there is no package called`    | Package not installed --- run `install.packages()` first |\n\n: Common R errors and their meanings {.striped}\n\nLet's see a common one in action:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Typo in variable name\negfr_value <- 68.9\negrf_value             # oops — \"egrf\" instead of \"egfr\"\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in eval(expr, envir, enclos): object 'egrf_value' not found\n```\n\n\n:::\n:::\n\n\nR tells you exactly what it can't find. Read the message, spot the typo, and fix it.\n\nHere's another common one --- calling a function from a package you haven't loaded:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_csv(\"data/diabetes.csv\")\n```\n:::\n\n\n```\nError in read_csv(\"data/diabetes.csv\") :\n  could not find function \"read_csv\"\n```\n\nThe fix: add `library(readr)` or `library(tidyverse)` at the top of your script.\n\n::: {.callout-tip}\n## The debugging habit\n\nWhen you see an error:\n\n1. **Read** the error message carefully\n2. **Look** at the line it points to\n3. **Check** for typos, missing parentheses, or unloaded packages\n4. If stuck, **copy-paste** the error message into a search engine or ask an AI assistant --- chances are, someone has had the same problem before\n:::\n\n\n## Summary\n\nIn this chapter, you've learned the core building blocks of R programming. Here's the journey we took with our eGFR example:\n\n| Step    | What we did                              | R concept             |\n|---------|------------------------------------------|-----------------------|\n| Start   | `(140 - 55) * 70 / (72 * 1.2)`          | Arithmetic operators  |\n| Store   | `age`, `weight_kg`, `creatinine`         | Variables             |\n| Verify  | `typeof()`, `class()`                    | Data types            |\n| Scale   | 5 patients at once                       | Vectors               |\n| Filter  | `egfrs < 60`                             | Logical comparisons   |\n| Handle  | Missing creatinine                       | `NA` and `na.rm`      |\n| Decide  | CKD staging                              | `if` / `else if` / `else` |\n| Wrap    | `estimate_egfr()`                        | Functions             |\n| Chain   | `\\|>`                                    | Pipes                 |\n\nThese fundamentals are the foundation for everything that follows. In the next chapter, we'll learn about **data frames** --- R's structure for tabular data --- and start working with real medical datasets.\n\n\n## Exercises {.unnumbered}\n\n1. **BMI calculator.** Create variables `weight_kg` and `height_m` for a patient, then calculate BMI using the formula: $BMI = weight / height^2$. What is the BMI of a patient who weighs 85 kg and is 1.72 m tall?\n\n2. **Blood pressure classifier.** Write an `if` / `else if` / `else` statement that classifies a systolic blood pressure value (`sbp`) into:\n   - \"Normal\" (below 120)\n   - \"Elevated\" (120--129)\n   - \"High\" (130 or above)\n\n   Test it with `sbp <- 135`.\n\n3. **Temperature converter.** Write a function `f_to_c()` that converts Fahrenheit to Celsius using the formula: $C = (F - 32) \\times 5/9$. Test it with 98.6°F (normal body temperature) and 104°F (fever).\n\n4. **Lab value analysis.** Given this vector of hemoglobin values (g/dL):\n\n   ::: {.cell}\n   \n   ```{.r .cell-code}\n   hgb <- c(12.5, NA, 15.2, 10.8, 14.1, NA, 11.3)\n   ```\n   :::\n\n   Answer these questions using R:\n\n   a. How many values are missing?\n   b. What is the mean hemoglobin, excluding missing values?\n   c. How many patients have hemoglobin below 12 g/dL (a simplified anemia threshold)?\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}